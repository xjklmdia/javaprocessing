//control variables
//0:initial variable
//1:game screen
//2:game over screen
int gameScreen =0;
//ball
float ballX, ballY;
int ballSize =20;
int ballColor = color(255,0,0);
//racket
int racketColor = color(0);
int racketimpact =20;
float racketWidth =100;
float racketHeight = 10;
float lastAddTime =0;
//healthbar
int maxHealth = 100;
int healthBarW=60;
float health = 100;
float healthDecrease = 1;
//gravity
float gravity =.5;
float ballSpeedVert =0;
float ballHspeed =0;
//friction
float ACOF = 0.0001;
float KOF = 0.1;
//wall
int wallSpeed = 3;
int wallInt =1000;
int minGH=200;
int maxGH=300;
int wallWidth=80;
int wallColor = color(0);
ArrayList<int[]>walls = new ArrayList<int[]>();
//
void setup(){
    size(500,500);
    ballX=width/4;
    ballY=height/5;
    noStroke();
    noCursor();
  }
//
void draw(){
    if(gameScreen==0){
      initScreen();
  } else if(gameScreen==1){
      gameScreen();
  } else if (gameScreen==2){
      gameOverScreen();
    }
  }
//screen content
void initScreen(){
// initial
    background(0);
    textAlign(CENTER);
    text("click to start", width/2, height/2);
    text("your probably going to lose",width/2,height-50);
  }

void gameScreen(){
// gamescreen
    background(255);
    drawBall();
    watchRacket();
    drawRacket();
    applyGravity();
    applyHSpeed();
    wallAdder();
    wallHandler();
    drawHealthBar();
    keepInScreen();
  }
  
void gameOverScreen(){
  //game over
  background(0);
  textAlign(CENTER);
  text("you suck", height/2, width/2-20);
  textSize(15);
  text("click to restart", height/2, width/2 +10);
  }
//

//input
public void mousePressed(){
    if(gameScreen==0){
    startGame();
    }
    if(gameScreen==2){
   //
    }  
  }
//

//functions
void startGame(){
  gameScreen=1;
  }
  
void gameOver(){
  gameScreen=2;
}

  
  void applyGravity(){
    ballSpeedVert +=gravity;
    ballY+= ballSpeedVert;
    ballSpeedVert -=(ballSpeedVert *ACOF);
  }

  void applyHSpeed(){
    ballX+= ballHspeed;
    ballHspeed -=(ballHspeed *ACOF);
  }

  void makeBounceBottom(float surface){
    ballY = surface - (ballSize/2);
    ballSpeedVert *= -1;
  ballSpeedVert -=(ballSpeedVert *KOF);
  }

  void makeBounceLeft(float surface){
    ballX = surface + (ballSize/2);
    ballHspeed *=-1;
    ballHspeed -= (ballHspeed *KOF);
  }

  void makeBounceRight(float surface){
    ballX = surface - (ballSize/2);
    ballHspeed *=-1;
    ballHspeed -= (ballHspeed *KOF);
  }

  void makeBounceTop(float surface){
   ballY = surface + (ballSize/2);
   ballSpeedVert *= -1;
   ballSpeedVert -=(ballSpeedVert *KOF);
  }

  void keepInScreen(){
    //ball hits floor
   if(ballY+(ballSize/2)>height){
     makeBounceBottom(height);
    }
//ball hits ceiling
  if(ballY-(ballSize/2)<0){
    makeBounceTop(0);
    }
//ball hits Left
  if(ballX-(ballSize/2)<0){
    makeBounceLeft(0);
    }
//ball hits right
  if(ballX-(ballSize/2)> width){
    makeBounceRight(width);
    }
  }

  void drawBall(){
    fill(ballColor);
    ellipse(ballX,ballY,ballSize,ballSize);
  }

  void drawRacket(){
    fill(racketColor);
    rectMode(CENTER);
    rect(mouseX,mouseY,racketWidth,racketHeight);
  }

 void watchRacket(){
 float overhead = mouseY-pmouseY;
   if((ballX+(ballSize/2)> mouseX-(racketWidth/2)) && (ballX-(ballSize/2) < mouseX+(racketWidth/2))){
     if(dist(ballX,ballY, ballX,mouseY)<=(ballSize/2)+abs(overhead)){
       makeBounceBottom(mouseY);
         if(overhead<0);{
           ballY+=overhead;
           ballHspeed = (ballX - mouseX)/5;
           ballSpeedVert+=overhead;
     }
    }
   }
  }

  void wallAdder(){
    if(millis()-lastAddTime > wallInt){
      int randHeight = round(random(minGH, maxGH));
      int randY = round(random(0,height-randHeight));
      int[] randWall = {width,randY,wallWidth,randHeight};
      walls.add(randWall);
      lastAddTime=millis();
   }
  }

  void wallHandler(){
    for(int i =0; i< walls.size(); i++){
      wallRemover(i);
      wallMover(i);
      wallDrawer(i);
      watchWallCollision(i);
    }
  }

  void wallDrawer(int index){
    int[] wall= walls.get(index);
      int gapWallX = wall[0];
      int gapWallY = wall[1];
      int gapWallW = wall[2];
      int gapWallH = wall[3];
  
    rectMode(CORNER);
    fill(wallColor);
    rect(gapWallX, 0 ,gapWallW, gapWallY);
    rect(gapWallX, gapWallY+ gapWallH, gapWallW,height -(gapWallY+ gapWallH));
  }

  void wallMover( int index){
    int[] wall = walls.get(index);
    wall[0] -= wallSpeed;
  }

  void wallRemover(int index){
    int[] wall = walls.get(index);
    if(wall[0] +wall[2] <= 0){
    walls.remove(index);
    }
  }
  
  void watchWallCollision(int index){
    int[] wall = walls.get(index);
    int gapWallX = wall[0];
    int gapWallY = wall[1];
    int gapWallW = wall[2];
    int gapWallH = wall[3];
    int wallTopX = gapWallX;
    int wallTopY = 0;
    int wallTopW = gapWallW;
    int wallTopH = gapWallY;
    int wallBottomX = gapWallX;
    int wallBottomY = gapWallY + gapWallH;
    int wallBottomW = gapWallW;
    int wallBottomH = height-(gapWallY+gapWallH);
  
    if(
    (ballX+(ballSize/2)>wallTopX) &&
    (ballX-(ballSize/2)<wallTopX+wallTopW) &&
    (ballY+(ballSize/2)>wallTopY) &&
    (ballY-(ballSize/2)<wallTopY+wallTopH)
    ) {
      //collision check upper
    }
    
    if(
    (ballX+(ballSize/2)>wallBottomX) &&
    (ballX-(ballSize/2)<wallBottomX+wallBottomW) &&
    (ballY+(ballSize/2)>wallBottomY) &&
    (ballY-(ballSize/2)<wallBottomY+wallBottomH)
    ) {
     //collision check lower
    }
  }
  
  void drawHealthBar(){
  noStroke();
  fill(250,240,230);
  //bar initial
  rectMode(CORNER);
  rect(ballX-(healthBarW/2), ballY-30,healthBarW, 5);
  if (health>60){
    fill(50,200,110);
  }else if (health > 30){
    fill(230,120,30);
  }else {
    fill(231,75,60);
    }
    //secondary bar dynamic
   rectMode(CORNER);
   rect(ballX-(healthBarW/2), ballY-30, healthBarW*(health/maxHealth),5);
  }
  
  void decreaseHealth(){
    health -= healthDecrease;
    if(health <=0){
     gameOver();
   }
  }
//
